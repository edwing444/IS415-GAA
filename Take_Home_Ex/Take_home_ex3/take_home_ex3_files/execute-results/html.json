{
  "hash": "b82ed34353a578fb9a72ee0021411cc5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take Home Exercise 3\"\nauthor: \"Edwin Tan\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf,tmap,tidyverse,spatstat,raster,sparr,spdep,sfdep,spgwr,exactextractr)\n```\n:::\n\n\n# Reading data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Import administrative boundary data for vietnam\nboundary_data <- st_read(dsn=\"data/geospatial\",\n                         layer = \"vnm_admbnda_adm1_gov_20201027\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `vnm_admbnda_adm1_gov_20201027' from data source \n  `C:\\edwing444\\IS415-GAA\\Take_Home_Ex\\Take_home_ex3\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 63 features and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 102.144 ymin: 7.180931 xmax: 117.8355 ymax: 23.39221\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2012_data <- read.csv(\"data/aspatial/2012.csv\")\nPCI_2013_data <- read.csv(\"data/aspatial/2013.csv\")\nPCI_2014_data <- read.csv(\"data/aspatial/2014.csv\")\nPCI_2015_data <- read.csv(\"data/aspatial/2015.csv\")\nPCI_2016_data <- read.csv(\"data/aspatial/2016.csv\")\nPCI_2017_data <- read.csv(\"data/aspatial/2017.csv\")\nPCI_2018_data <- read.csv(\"data/aspatial/2018.csv\")\nPCI_2019_data <- read.csv(\"data/aspatial/2019.csv\")\nPCI_2020_data <- read.csv(\"data/aspatial/2020.csv\")\nPCI_2021_data <- read.csv(\"data/aspatial/2021.csv\")\nPCI_2022_data <- read.csv(\"data/aspatial/2022.csv\")\n```\n:::\n\n\n# Cleaning data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboundary_data <- boundary_data %>%\n  dplyr::select(-ADM1_VI,-ADM1_REF,-ADM1ALT1EN,-ADM1ALT2EN,-ADM1ALT1VI,-ADM1ALT2EN, -ADM1ALT2VI, -ADM0_VI,-ADM0_EN,-ADM0_PCODE,-date,-validOn,-validTo,-ADM1_PCODE) %>% \n  rename(province = ADM1_EN)\n```\n:::\n\n\n::: panel-tabset\n## 2012\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2012_data <- PCI_2012_data %>%\n  dplyr::select(-X,-X.1,-X.2,-X.3,-X.4,-X.5, -X.6, -X.7,-X.8,-X.9,-X.10,-No) %>% \n  rename(province = Province)\n```\n:::\n\n\n## 2013\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2013_data <- PCI_2013_data %>%\n  dplyr::select(-X,-X.1,-X.2,-X.3,-X.4,-X.5, -X.6, -X.7,-X.8,-X.9,-PCI.2013.ranking,-No) %>% \n  rename(province = Province)\n```\n:::\n\n\n## 2014\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2014_data <- PCI_2014_data %>%\n  dplyr::select(-X,-X.1,-X.2,-X.3,-X.4,-X.5, -X.6, -X.7,-X.8,-X.9,-PCI.2014.ranking,-No) %>% \n  rename(province = Province)\n```\n:::\n\n\n## 2015\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2015_data <- PCI_2015_data %>%\n  dplyr::select(-X,-X.1,-X.2,-X.3,-X.4,-X.5, -X.6, -X.7,-X.8,-X.9,-PCI.2015.ranking,-No) %>% \n  rename(province = Province)\n```\n:::\n\n\n## 2016\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2016_data <- PCI_2016_data %>%\n  dplyr::select(-X,-X.1,-X.2,-X.3,-X.4,-X.5, -X.6, -X.7,-X.8,-X.9,-X.10,-X.11,-PCI.2016.ranking,-No) %>% \n  rename(province = Province)\n```\n:::\n\n\n## 2017\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2017_data <- PCI_2017_data %>%\n  dplyr::select(-Rank) %>% \n  rename(province = Province)\n```\n:::\n\n:::\n\n::: panel-tabset\n## 2018\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2018_data <- PCI_2018_data %>%\n  dplyr::select(-Rank) %>% \n  rename(province = Province)\n```\n:::\n\n\n## 2019\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2019_data <- PCI_2019_data %>%\n  dplyr::select(-Rank) %>% \n  rename(province = Province)\n```\n:::\n\n\n## 2020\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2020_data <- PCI_2020_data %>%\n  rename(province = Province)\n```\n:::\n\n\n## 2021\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2021_data <- PCI_2021_data %>%\n  rename(province = Province)\n```\n:::\n\n\n## 2022\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2022_data <- PCI_2022_data %>%\n  rename(province = Province)\n```\n:::\n\n:::\n\n# Joining data\n\n::: panel-tabset\n## 2012\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2012_data <- boundary_data %>%\n  left_join(PCI_2012_data, by = \"province\")\n\nPCI_2012_data <- drop_na(PCI_2012_data)\n```\n:::\n\n\n## 2013\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2013_data <- boundary_data %>%\n  left_join(PCI_2013_data, by = \"province\")\n\nPCI_2013_data <- drop_na(PCI_2013_data)\n```\n:::\n\n\n## 2014\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2014_data <- boundary_data %>%\n  left_join(PCI_2014_data, by = \"province\")\n\nPCI_2014_data <- drop_na(PCI_2014_data)\n```\n:::\n\n\n## 2015\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2015_data <- boundary_data %>%\n  left_join(PCI_2015_data, by = \"province\")\n\nPCI_2015_data <- drop_na(PCI_2015_data)\n```\n:::\n\n\n## 2016\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2016_data <- boundary_data %>%\n  left_join(PCI_2016_data, by = \"province\")\n\nPCI_2016_data <- drop_na(PCI_2016_data)\n```\n:::\n\n\n## 2017\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2017_data <- boundary_data %>%\n  left_join(PCI_2017_data, by = \"province\")\n\nPCI_2017_data <- drop_na(PCI_2017_data)\n```\n:::\n\n:::\n\n::: panel-tabset\n## 2018\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2018_data <- boundary_data %>%\n  left_join(PCI_2018_data, by = \"province\")\n\nPCI_2018_data <- drop_na(PCI_2018_data)\n```\n:::\n\n\n## 2019\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2019_data <- boundary_data %>%\n  left_join(PCI_2019_data, by = \"province\")\n\nPCI_2019_data <- drop_na(PCI_2019_data)\n```\n:::\n\n\n## 2020\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2020_data <- boundary_data %>%\n  left_join(PCI_2020_data, by = \"province\")\n\nPCI_2020_data <- drop_na(PCI_2020_data)\n```\n:::\n\n\n## 2021\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2021_data <- boundary_data %>%\n  left_join(PCI_2021_data, by = \"province\")\n\nPCI_2021_data <- drop_na(PCI_2021_data)\n```\n:::\n\n\n## 2022\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPCI_2022_data <- boundary_data %>%\n  left_join(PCI_2022_data, by = \"province\")\n\nPCI_2022_data <- drop_na(PCI_2022_data)\n```\n:::\n\n:::\n\n# Preparing and Computing Data for Global Moran I\n\n::: panel-tabset\n## 2012\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Create spatial weights matrix (Queen Contiguity)\ncoords_global_2012 <- st_centroid(st_geometry(PCI_2012_data)) # Use centroids of polygons\nnb_global_2012 <- poly2nb(PCI_2012_data, queen = TRUE) # Create neighbors list using queen contiguity\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in poly2nb(PCI_2012_data, queen = TRUE): neighbour object has 2 sub-graphs;\nif this sub-graph count seems unexpected, try increasing the snap argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nlw_global_2012 <- nb2listw(nb_global_2012, style = \"W\") # Convert to weights list (row-standardized)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#covert to numeric for PCI 2012\nPCI_2012_data$PCI.2012 <- as.numeric(PCI_2012_data$PCI.2012)\n# Step 2: Compute Global Moran's I\nglobal_moran_2012 <- moran.test(PCI_2012_data$PCI.2012, lw_global_2012)\n# Step 3: Print the results\nprint(global_moran_2012)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  PCI_2012_data$PCI.2012  \nweights: lw_global_2012    \n\nMoran I statistic standard deviate = 1.0588, p-value = 0.1448\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.080655874      -0.017543860       0.008601753 \n```\n\n\n:::\n:::\n\n\n## 2013\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Create spatial weights matrix (Queen Contiguity)\ncoords_global_2013 <- st_centroid(st_geometry(PCI_2013_data)) # Use centroids of polygons\nnb_global_2013 <- poly2nb(PCI_2013_data, queen = TRUE) # Create neighbors list using queen contiguity\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in poly2nb(PCI_2013_data, queen = TRUE): neighbour object has 2 sub-graphs;\nif this sub-graph count seems unexpected, try increasing the snap argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nlw_global_2013 <- nb2listw(nb_global_2013, style = \"W\") # Convert to weights list (row-standardized\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#covert to numeric for PCI 2013\nPCI_2013_data$PCI.2013 <- as.numeric(PCI_2013_data$PCI.2013)\n# Step 2: Compute Global Moran's I\nglobal_moran_2013 <- moran.test(PCI_2013_data$PCI.2013, lw_global_2013)\n# Step 3: Print the results\nprint(global_moran_2013)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  PCI_2013_data$PCI.2013  \nweights: lw_global_2013    \n\nMoran I statistic standard deviate = 0.34859, p-value = 0.3637\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.015240668      -0.017857143       0.009015275 \n```\n\n\n:::\n:::\n\n\n## 2014\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Create spatial weights matrix (Queen Contiguity)\ncoords_global_2014 <- st_centroid(st_geometry(PCI_2014_data)) # Use centroids of polygons\nnb_global_2014 <- poly2nb(PCI_2014_data, queen = TRUE) # Create neighbors list using queen contiguity\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in poly2nb(PCI_2014_data, queen = TRUE): neighbour object has 2 sub-graphs;\nif this sub-graph count seems unexpected, try increasing the snap argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nlw_global_2014 <- nb2listw(nb_global_2014, style = \"W\") # Convert to weights list (row-standardized\n```\n:::\n\n\n### Computing Global Moran I\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#covert to numeric for PCI 2013\nPCI_2014_data$PCI.2014 <- as.numeric(PCI_2014_data$PCI.2014)\n# Step 2: Compute Global Moran's I\nglobal_moran_2014 <- moran.test(PCI_2014_data$PCI.2014, lw_global_2014)\n# Step 3: Print the results\nprint(global_moran_2014)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  PCI_2014_data$PCI.2014  \nweights: lw_global_2014    \n\nMoran I statistic standard deviate = 1.2237, p-value = 0.1105\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.095226635      -0.017543860       0.008493219 \n```\n\n\n:::\n:::\n\n\n## 2015\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Create spatial weights matrix (Queen Contiguity)\ncoords_global_2015 <- st_centroid(st_geometry(PCI_2015_data)) # Use centroids of polygons\nnb_global_2015 <- poly2nb(PCI_2015_data, queen = TRUE) # Create neighbors list using queen contiguity\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in poly2nb(PCI_2015_data, queen = TRUE): neighbour object has 2 sub-graphs;\nif this sub-graph count seems unexpected, try increasing the snap argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nlw_global_2015 <- nb2listw(nb_global_2015, style = \"W\") # Convert to weights list (row-standardized\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#covert to numeric for PCI 2013\nPCI_2015_data$PCI.2015 <- as.numeric(PCI_2015_data$PCI.2015)\n# Step 2: Compute Global Moran's I\nglobal_moran_2015 <- moran.test(PCI_2015_data$PCI.2015, lw_global_2015)\n# Step 3: Print the results\nprint(global_moran_2015)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  PCI_2015_data$PCI.2015  \nweights: lw_global_2015    \n\nMoran I statistic standard deviate = 0.02337, p-value = 0.4907\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     -0.015450764      -0.017543860       0.008021871 \n```\n\n\n:::\n:::\n\n\n## 2016\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Create spatial weights matrix (Queen Contiguity)\ncoords_global_2016 <- st_centroid(st_geometry(PCI_2016_data)) # Use centroids of polygons\nnb_global_2016 <- poly2nb(PCI_2016_data, queen = TRUE) # Create neighbors list using queen contiguity\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in poly2nb(PCI_2016_data, queen = TRUE): neighbour object has 2 sub-graphs;\nif this sub-graph count seems unexpected, try increasing the snap argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nlw_global_2016 <- nb2listw(nb_global_2016, style = \"W\") # Convert to weights list (row-standardized\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#covert to numeric for PCI 2013\nPCI_2016_data$PCI.2016 <- as.numeric(PCI_2016_data$PCI.2016)\n# Step 2: Compute Global Moran's I\nglobal_moran_2016 <- moran.test(PCI_2016_data$PCI.2016, lw_global_2016)\n# Step 3: Print the results\nprint(global_moran_2016)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  PCI_2016_data$PCI.2016  \nweights: lw_global_2016    \n\nMoran I statistic standard deviate = 0.51231, p-value = 0.3042\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.028698495      -0.017543860       0.008147358 \n```\n\n\n:::\n:::\n\n\n## 2017\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Create spatial weights matrix (Queen Contiguity)\ncoords_global_2017 <- st_centroid(st_geometry(PCI_2017_data)) # Use centroids of polygons\nnb_global_2017 <- poly2nb(PCI_2017_data, queen = TRUE) # Create neighbors list using queen contiguity\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in poly2nb(PCI_2017_data, queen = TRUE): neighbour object has 2 sub-graphs;\nif this sub-graph count seems unexpected, try increasing the snap argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nlw_global_2017 <- nb2listw(nb_global_2017, style = \"W\") # Convert to weights list (row-standardized\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#covert to numeric for PCI 2013\nPCI_2017_data$The.Weighted.PCI.Score.in.2017 <- as.numeric(PCI_2017_data$The.Weighted.PCI.Score.in.2017)\n# Step 2: Compute Global Moran's I\nglobal_moran_2017 <- moran.test(PCI_2017_data$The.Weighted.PCI.Score.in.2017, lw_global_2017)\n# Step 3: Print the results\nprint(global_moran_2017)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  PCI_2017_data$The.Weighted.PCI.Score.in.2017  \nweights: lw_global_2017    \n\nMoran I statistic standard deviate = 1.0397, p-value = 0.1492\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.078207500      -0.017543860       0.008481661 \n```\n\n\n:::\n:::\n\n:::\n\n::: panel-tabset\n## 2018\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Create spatial weights matrix (Queen Contiguity)\ncoords_global_2018 <- st_centroid(st_geometry(PCI_2018_data)) # Use centroids of polygons\nnb_global_2018 <- poly2nb(PCI_2018_data, queen = TRUE) # Create neighbors list using queen contiguity\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in poly2nb(PCI_2018_data, queen = TRUE): neighbour object has 2 sub-graphs;\nif this sub-graph count seems unexpected, try increasing the snap argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nlw_global_2018 <- nb2listw(nb_global_2018, style = \"W\") # Convert to weights list (row-standardized\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#covert to numeric for PCI 2013\nPCI_2018_data$The.Weighted.PCI.Score.in.2018 <- as.numeric(PCI_2018_data$The.Weighted.PCI.Score.in.2018)\n# Step 2: Compute Global Moran's I\nglobal_moran_2018 <- moran.test(PCI_2018_data$The.Weighted.PCI.Score.in.2018, lw_global_2018)\n# Step 3: Print the results\nprint(global_moran_2018)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  PCI_2018_data$The.Weighted.PCI.Score.in.2018  \nweights: lw_global_2018    \n\nMoran I statistic standard deviate = 1.3862, p-value = 0.08284\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.109286862      -0.017543860       0.008370859 \n```\n\n\n:::\n:::\n\n\n## 2019\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Create spatial weights matrix (Queen Contiguity)\ncoords_global_2019 <- st_centroid(st_geometry(PCI_2019_data)) # Use centroids of polygons\nnb_global_2019 <- poly2nb(PCI_2019_data, queen = TRUE) # Create neighbors list using queen contiguity\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in poly2nb(PCI_2019_data, queen = TRUE): neighbour object has 2 sub-graphs;\nif this sub-graph count seems unexpected, try increasing the snap argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nlw_global_2019 <- nb2listw(nb_global_2019, style = \"W\") # Convert to weights list (row-standardized\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#covert to numeric for PCI 2013\nPCI_2019_data$The.Weighted.PCI.Score <- as.numeric(PCI_2019_data$The.Weighted.PCI.Score)\n# Step 2: Compute Global Moran's I\nglobal_moran_2019 <- moran.test(PCI_2019_data$The.Weighted.PCI.Score, lw_global_2019)\n# Step 3: Print the results\nprint(global_moran_2019)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  PCI_2019_data$The.Weighted.PCI.Score  \nweights: lw_global_2019    \n\nMoran I statistic standard deviate = 1.0163, p-value = 0.1547\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.075700054      -0.017543860       0.008418227 \n```\n\n\n:::\n:::\n\n\n## 2020\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Create spatial weights matrix (Queen Contiguity)\ncoords_global_2020 <- st_centroid(st_geometry(PCI_2020_data)) # Use centroids of polygons\nnb_global_2020 <- poly2nb(PCI_2020_data, queen = TRUE) # Create neighbors list using queen contiguity\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in poly2nb(PCI_2020_data, queen = TRUE): neighbour object has 2 sub-graphs;\nif this sub-graph count seems unexpected, try increasing the snap argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nlw_global_2020 <- nb2listw(nb_global_2020, style = \"W\") # Convert to weights list (row-standardized\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#covert to numeric for PCI 2013\nPCI_2020_data$The.Weighted.PCI.Score <- as.numeric(PCI_2020_data$The.Weighted.PCI.Score)\n# Step 2: Compute Global Moran's I\nglobal_moran_2020 <- moran.test(PCI_2020_data$The.Weighted.PCI.Score, lw_global_2020)\n# Step 3: Print the results\nprint(global_moran_2020)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  PCI_2020_data$The.Weighted.PCI.Score  \nweights: lw_global_2020    \n\nMoran I statistic standard deviate = 1.622, p-value = 0.0524\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.127824021      -0.017543860       0.008032511 \n```\n\n\n:::\n:::\n\n\n## 2021\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Create spatial weights matrix (Queen Contiguity)\ncoords_global_2021 <- st_centroid(st_geometry(PCI_2021_data)) # Use centroids of polygons\nnb_global_2021 <- poly2nb(PCI_2021_data, queen = TRUE) # Create neighbors list using queen contiguity\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in poly2nb(PCI_2021_data, queen = TRUE): neighbour object has 2 sub-graphs;\nif this sub-graph count seems unexpected, try increasing the snap argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nlw_global_2021 <- nb2listw(nb_global_2021, style = \"W\") # Convert to weights list (row-standardized\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#covert to numeric for PCI 2013\nPCI_2021_data$The.Weighted.PCI.Score <- as.numeric(PCI_2021_data$The.Weighted.PCI.Score)\n# Step 2: Compute Global Moran's I\nglobal_moran_2021 <- moran.test(PCI_2021_data$The.Weighted.PCI.Score, lw_global_2021)\n# Step 3: Print the results\nprint(global_moran_2021)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  PCI_2021_data$The.Weighted.PCI.Score  \nweights: lw_global_2021    \n\nMoran I statistic standard deviate = 2.0572, p-value = 0.01984\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.172186977      -0.017543860       0.008506331 \n```\n\n\n:::\n:::\n\n\n## 2022\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Create spatial weights matrix (Queen Contiguity)\ncoords_global_2022 <- st_centroid(st_geometry(PCI_2022_data)) # Use centroids of polygons\nnb_global_2022 <- poly2nb(PCI_2022_data, queen = TRUE) # Create neighbors list using queen contiguity\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in poly2nb(PCI_2022_data, queen = TRUE): neighbour object has 2 sub-graphs;\nif this sub-graph count seems unexpected, try increasing the snap argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nlw_global_2022 <- nb2listw(nb_global_2022, style = \"W\") # Convert to weights list (row-standardized\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#covert to numeric for PCI 2013\nPCI_2022_data$The.Weighted.PCI.Score <- as.numeric(PCI_2022_data$The.Weighted.PCI.Score)\n# Step 2: Compute Global Moran's I\nglobal_moran_2022 <- moran.test(PCI_2022_data$The.Weighted.PCI.Score, lw_global_2022)\n# Step 3: Print the results\nprint(global_moran_2022)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  PCI_2022_data$The.Weighted.PCI.Score  \nweights: lw_global_2022    \n\nMoran I statistic standard deviate = 2.7947, p-value = 0.002597\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.240860606      -0.017543860       0.008549129 \n```\n\n\n:::\n:::\n\n:::\n\n# Preparing Data for LISA\n\n::: panel-tabset\n## 2012\n\n## 2013\n\n## 2014\n\n## 2015\n\n## 2016\n\n## 2017\n:::\n\n::: panel-tabset\n## 2018\n\n## 2019\n\n## 2020\n\n## 2021\n\n## 2022\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q_2022 <- PCI_2022_data %>% \n  mutate(nb=st_contiguity(geometry),\n         wt=st_weights(nb,\n                       style=\"W\"),\n         .before = 1)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There was 1 warning in `stopifnot()`.\nℹ In argument: `nb = st_contiguity(geometry)`.\nCaused by warning in `spdep::poly2nb()`:\n! neighbour object has 2 sub-graphs;\nif this sub-graph count seems unexpected, try increasing the snap argument.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa_2022 <- wm_q_2022 %>% \n  mutate(local_moran = local_moran(\n    The.Weighted.PCI.Score,nb,wt,nsim=99),\n    .before=1) %>% \n  unnest(local_moran)\n```\n:::\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a spatial weights matrix\ncoords <- st_coordinates(st_centroid(PCI_2012_data))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: st_centroid assumes attributes are constant over geometries\n```\n\n\n:::\n\n```{.r .cell-code}\nnb <- knn2nb(knearneigh(coords, k = 4)) # K-nearest neighbors\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in knearneigh(coords, k = 4): knearneigh: identical points found\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in knearneigh(coords, k = 4): knearneigh: kd_tree not available for\nidentical points\n```\n\n\n:::\n\n```{.r .cell-code}\nlw <- nb2listw(nb, style = \"W\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate local Moran's I for each region\nlocal_moran_2012 <- localmoran(PCI_2012_data$PCI.2012, lw)\n\n# Add the results to the data for visualization\nPCI_2012_data$local_moran_2012 <- as.numeric(local_moran_2012[, \"Ii\"])\n```\n:::\n\n\n# Visualising LISA\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa_sig_2022 <- lisa_2022 %>% \n  filter(p_ii < 0.05)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(lisa_2022)+\n  tm_polygons()+\n  tm_borders(alpha=0.5)+\n  tm_shape(lisa_sig_2022)+\n  tm_fill(\"mean\")+\n  tm_borders(alpha=0.4)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](take_home_ex3_files/figure-html/unnamed-chunk-54-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n tm_shape(lisa_2022)+\n  tm_fill('ii')+\n  tm_borders(alpha=0.5)+\n  tm_view(set.zoom.limits = c(5,8))+\n  tm_layout(\n    main.title = \"local Moran's I of G\",\n    main.title.size = 2\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nVariable(s) \"ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](take_home_ex3_files/figure-html/unnamed-chunk-55-1.png){width=672}\n:::\n:::\n\n\nBelow is my sdep lisa cluster\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create the LISA cluster map\ntm_shape(PCI_2012_data) +\n  tm_polygons(\"local_moran_2012\", \n              title = \"Local Moran's I (PCI Clusters)\", \n              palette = \"RdBu\", \n              style = \"cont\") + \n  tm_layout(main.title = \"LISA Cluster Map: PCI\", \n            legend.outside = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nVariable(s) \"local_moran_2012\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](take_home_ex3_files/figure-html/unnamed-chunk-56-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate Getis-Ord Gi* statistic for each region\ngi_star <- localG(PCI_2012_data$PCI.2012, lw)\n\n# Add Gi* values to the data\nPCI_2012_data$gi_star <- as.numeric(gi_star)\n\n# Create a hotspot map\ntm_shape(PCI_2012_data) +\n  tm_polygons(\"gi_star\", \n              title = \"Getis-Ord Gi* (HDI Hotspots)\", \n              palette = \"YlOrRd\", \n              style = \"cont\") + \n  tm_layout(main.title = \"Hotspot Analysis: HDI\", \n            legend.outside = TRUE)\n```\n\n::: {.cell-output-display}\n![](take_home_ex3_files/figure-html/unnamed-chunk-57-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "take_home_ex3_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}